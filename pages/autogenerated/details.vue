<template>
  <div class="details-page container">
    <div>
      <div><strong>Requested stops</strong></div>
      <ol>
        <li v-for="(stop, stopIndex) in stops" :key="`${stop.index}, ${stopIndex}`">
          ({{dateformat(stop.time, 'h:MM TT', true)}})
          <a href="#" @click.prevent="viewStop(stop)">
            {{stop.description}}
          </a>
        </li>
      </ol>

      <div v-if="this.time !== null">
        <strong>Requested Arrival Time:</strong>
        {{dateformat(this.time, 'h:MM TT', true)}}
      </div>

      <hr/>

      <div>
        Total number of requests served: <strong>{{relatedRequests && relatedRequests.length}}</strong>
      </div>

      <requests-time-histogram :requests="relatedRequests"
        :width="320" :height="350">
      </requests-time-histogram>

      <SuggestionEmailList v-for="[time, requests] in relatedRequestsByTime"
        :key="time"
        :time="time"
        :requests="requests"
      />
    </div>
    <GmapMap class="gmap"
        :center="{lat: 1.38, lng: 103.8}" :zoom="11"
        :options="{gestureHandling: 'greedy'}"
        ref="proposed-route-map">

      <RoutePathAndStops :stops="stops" />
      <SuggestionMarker v-for="(req, index) in relatedRequests"
        :key="`board-${index}`"
        :position="req.start" />
      <SuggestionMarker v-for="(req, index) in relatedRequests"
        :key="`alight-${index}`"
        :position="req.end" />
    </GmapMap>
  </div>
</template>

<style lang="scss">
 .details-page {
   min-height: 400px;
   display: flex;
   flex-direction: row;

   .gmap {
     flex: 1 1 auto;
   }
 }
</style>

<script>
import {keyBy, groupBy, toPairs, sortBy} from 'lodash'
import axios from 'axios'
import dateformat from 'dateformat'
import querystring from 'querystring'
import RoutePathAndStops from '~/components/autogenerated/RoutePathAndStops'
import SuggestionMarker from '~/components/autogenerated/SuggestionMarker'
import SuggestionEmailList from '~/components/autogenerated/SuggestionEmailList'
import RequestsTimeHistogram from '~/components/suggest/RequestsTimeHistogram'

export default {
  layout: 'landing',

  components: {
    RequestsTimeHistogram, RoutePathAndStops, SuggestionMarker, SuggestionEmailList
  },

  async asyncData (params) {
    const stopIndices = params.query.stops.split(',').map(s => parseInt(s))
    const path = stopIndices.join('/')

    const [
      stopDetailsReq, matchingRequestsReq, travelTimesReq
    ] = await Promise.all([
      axios.get(
        `${process.env.beelineRoutingServer}/bus_stops`
      ),
      axios.get(
        `${process.env.beelineRoutingServer}/path_requests/${path}?` + querystring.stringify({
          maxDistance: 400, /* Should match setting in autogenerated.vue */
        })
      ),
      axios.get(
        `${process.env.beelineRoutingServer}/travel_times/${path}`
      )
    ])

    return {
      allStops: stopDetailsReq.data,
      relatedRequests: matchingRequestsReq.data,
      travelTimes: travelTimesReq.data,
    }
  },

  data () {
    return {
      allStops: null,
      relatedRequests: null,
      travelTimes: null,
    }
  },

  computed: {
    allStopsById () {
      return this.allStops && keyBy(this.allStops, 'index')
    },

    time () {
      if (this.$route.query.time) {
        return parseInt(this.$route.query.time)
      } else {
        return null
      }
    },

    arrivalTimes () {
      if (!this.travelTimes) return null
      // Reverse is in-place! Hence the map
      const reverseTravelTimes = this.travelTimes.map(x => x).reverse()
      const arrivalTimes = reverseTravelTimes.reduce(
        (acc, travelTime) => {
          /* Currently beeline-routing assumes 1-minute dwell times */
          acc.push(acc[acc.length - 1] - travelTime - 60000)
          return acc
        },
        [this.time]
      )
      arrivalTimes.reverse()
      return arrivalTimes
    },

    stops () {
      if (this.allStopsById) {
        return this.$route.query
          .stops.split(',')
          .map(s => this.allStopsById[parseInt(s)])
          .map((s, i) => {
            /* oops something is funny in our API */
            s.lat = s.coordinates[1]
            s.lng = s.coordinates[0]
            s.time = this.arrivalTimes[i]
            return s
          })
      }
    },

    relatedRequestsByTime () {
      if (this.relatedRequests) {
        return sortBy(
          toPairs(
            groupBy(this.relatedRequests, s => s.time)
          ),
          ([time, requests]) => parseInt(time)
        )
      }
    },

    dateformat: () => dateformat,
  },

  methods: {
    viewStop (stop) {
      const {lat, lng} = stop
      this.$refs['proposed-route-map'].panTo({lat: parseFloat(lat), lng: parseFloat(lng)})
      if (this.$refs['proposed-route-map'].$mapObject.getZoom() < 15) {
        this.$refs['proposed-route-map'].$mapObject.setZoom(17)
      }
    },
  }
}

</script>
