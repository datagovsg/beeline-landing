<template>
  <div>
    <ul class="nav nav-tabs">
      <router-link tag="li" active-class="active" to="/search">
        <a>Search</a>
      </router-link>
      <router-link tag="li" active-class="active" to="/running">
        <a>Running Routes <span v-if="runningRoutes">({{runningRoutes.length}})</span></a>
      </router-link>
      <router-link tag="li" active-class="active" to="/crowdstarted">
        <a>Crowdstart Routes <span v-if="crowdstartedRoutes">({{crowdstartedRoutes.length}})</span></a>
      </router-link>
      <router-link tag="li" active-class="active" to="/autogenerated">
        <a>Autogenerated Routes <span v-if="autogeneratedRoutes">({{autogeneratedRoutes.length}})</span></a>
      </router-link>
      <router-link tag="li" active-class="active" to="/new">
        <a>New Crowdstart Route</a>
      </router-link>
      <li>
        <img src="/static/img/loading.svg" v-show="loadingRequests"
          class="loading-spinner" />
      </li>
    </ul>
    <keep-alive>
      <router-view></router-view>
    </keep-alive>
  </div>
</template>
<style lang="scss">
.loading-spinner {
  max-height: 1.5em;
}
</style>
<script>
import ProposedRouteViewer from './components/proposed-route-viewer.vue';
import ExistingRouteViewer from './components/existing-route-viewer.vue';
import CrowdstartFromRoute from './components/crowdstart-from-route.vue';
import MapPreview from './components/map-preview.vue';
import RouteViewer from './components/route-viewer.vue';
import SimilarRequests from './components/similar-requests.vue';
import {mapState} from 'vuex';

import querystring from 'querystring';
import scrollTo from './utils/scrollTo';

export default {
  name: 'app',
  components: {
    ExistingRouteViewer,
    MapPreview,
    ProposedRouteViewer,
    CrowdstartFromRoute,
    RouteViewer,
    SimilarRequests
  },
  data() {
    return {
      searchSettings: {
        maxDetourMinutes: 2,
        startClusterRadius: 4000,
        endClusterRadius: 4000,
        startWalkingDistance: 300,
        endWalkingDistance: 300,
        dataSource: 'suggestions'
      },

      crowdstarting: {
        derived: null,
      },
    }
  },
  computed: {
    ...mapState(['crowdstartedRoutes', 'runningRoutes', 'autogeneratedRoutes',
    'loadingRequests'])
  },
  methods: {
    updatePlace(which, latLng) {
      if (latLng) {
        this.$set(this, which, latLng)
        this.updateRoutes();
      } else {
        this.$set(this, which, null);
      }
    },
    updateRoutes() {
      if (this.origin && this.destination) {
        this.updateProposedRoutes();
        this.updateLiveRoutes();
        this.updateSimilarRequests();
      }
    },
    updateLiveRoutes() {
      if (this.origin && this.destination) {
        this.$http.get('https://api.beeline.sg/routes/search_by_latlon?' + querystring.stringify({
          startLat: this.origin.lat,
          startLng: this.origin.lng,
          endLat: this.destination.lat,
          endLng: this.destination.lng,
          maxDistance: this.maxDistance,
          tags: JSON.stringify(['public']),
        }))
        .then(r => r.json())
        .then(rs => {
          for (let route of rs) {
            for (let trip of route.trips) {
              trip.tripStops = _.sortBy(trip.tripStops, 'time')
            }
          }
          rs.trips = _.sortBy(rs.trips, 'date')
          this.liveRoutes = rs;
        });
      }
    },
    updateLatLng(which, what) {
      this.updatePlace(which, what);

      // additionally reverse geocode
      geocode(what)
      .then(r => {
        this.$set(this.search, which, r[0].formatted_address)
      })
    },
    updateSimilarRequests() {
      if (this.origin && this.destination) {
        this.$http.get('https://api.beeline.sg/suggestions/web/similar?' + querystring.stringify({
          startLat: this.origin.lat,
          startLng: this.origin.lng,
          endLat: this.destination.lat,
          endLng: this.destination.lng,
        }))
        .then(r => r.json())
        .then(rs => this.similarRequests = rs);
      } else {
        this.similarRequests = []
      }
    },
    selectRoute(route) {
      this.disp.selectedRoute = route;
    }
  }
}

function latlngDistance(ll1, ll2) {
  var rr1 = [ll1[0] / 180 * Math.PI, ll1[1] / 180 * Math.PI]
  var rr2 = [ll2[0] / 180 * Math.PI, ll2[1] / 180 * Math.PI]

  var dx = (rr1[1] - rr2[1]) * Math.cos(0.5 * (rr1[0] + rr2[0]))
  var dy = rr1[0] - rr2[0]

  var dist = Math.sqrt(dx * dx + dy * dy) * 6371000
  return dist
}


</script>

<style lang="sass">
</style>
