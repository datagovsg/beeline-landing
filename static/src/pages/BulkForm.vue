<template>
  <form class="bulk-form" ref="bulkForm">

    <div class="routes-list">
      <table class="routes-list-table table table-striped">
      <tbody>
        <tr v-for="cluster in clusters">
          <td>{{cluster.index + 1}}</td>
          <td>{{cluster.geocodedStart || `${cluster.start.lat}, ${cluster.start.lng}`}}</td>
          <td>{{cluster.geocodedEnd || `${cluster.start.lat}, ${cluster.start.lng}`}}</td>
          <td>{{cluster.score}}</td>
          <td><button type="button" @click="use(cluster)">Use</button></td>
        </tr>
      </tbody>
      </table>
    </div>

  </form>
</template>

<style lang="scss">
</style>

<script>
import mapSettings from '../components/mapSettings.js';
import { mapGetters, mapState, mapActions, mapMutations } from 'vuex'
import ExistingRouteViewer from '../components/existing-route-viewer.vue';
import SimilarRequests from '../components/similar-requests.vue';
import RouteViewer from '../components/route-viewer.vue';
import MapPreview from '../components/map-preview.vue';
import LoadingSpinner from '../components/loading-spinner.vue';
import {geocodeOM} from '../utils/geocoder';
import rawData from '../clusters.json';

export default {
  props: ['origin', 'destination'],
  components: {
    ExistingRouteViewer,
    MapPreview,
    RouteViewer,
    SimilarRequests,
    LoadingSpinner
  },
  data() {
    return {
      rawData: JSON.stringify(rawData),
      clusters: [],
      mapSettings,
      originText: '',
      destinationText: '',
    }
  },
  computed: {
    ...mapState(['origin', 'destination', 'selectedRoute', 'similarRequests',
      'autogeneratedRoutes', 'crowdstartedRoutes', 'runningRoutes',
      'loadingRequests']),
  },
  watch: {
    rawData: {
      immediate: true,
      handler () {
        // this.clusters = this.rawData.trim().split("\n")
        //   .map(line => {
        //     var parts = line.split(',')
        //     return {
        //       start: {
        //         lat: parseFloat(parts[1]),
        //         lng: parseFloat(parts[2]),
        //       },
        //       end: {
        //         lat: parseFloat(parts[3]),
        //         lng: parseFloat(parts[4]),
        //       },
        //       geocodedStart: null,
        //       geocodedEnd: null,
        //       index: parts[0],
        //     }
        //   })

        // for (let cluster of this.clusters) {
        //   this.geocode(cluster)
        // }
        try {
          this.clusters = JSON.parse(this.rawData)
            .filter(cluster => cluster.score > 2)
            .map(cluster => ({
              start: {
                lat: cluster.startLat,
                lng: cluster.startLng,
              },
              end: {
                lat: cluster.endLat,
                lng: cluster.endLng,
              },
              geocodedStart: cluster.geocodedStart,
              geocodedEnd: cluster.geocodedEnd,
              index: cluster.index,
              score: cluster.score
            }))
        } catch (err) {
        }
      }
    }
  },
  methods: {
    ...mapMutations(['setOrigin', 'setDestination']),
    latLngFromPlace(place) {
      if (place.geometry) {
        return {
          lat: place.geometry.location.lat(),
          lng: place.geometry.location.lng(),
        }
      }
    },
    goNext() {
      this.$store.dispatch('processRequest')
    },
    updateLatLng(which, what) {
      if (which === 'origin') {
        this.setOrigin(what);
      } else if (which === 'destination') {
        this.setDestination(what)
      } else {
        throw new Error('`which` should be "origin" or "destination"')
      }

      // additionally reverse geocode
      geocode(what)
      .then(r => {
        this.$set(this, which + 'Text', r[0].formatted_address)
      })
    },
    updateFromText(event) {
      var s = event.target.value;

      var parts = s.split(/,/g)

      this.setOrigin({lat: parseFloat(parts[1]), lng: parseFloat(parts[2])})
      this.setDestination({lat: parseFloat(parts[3]), lng: parseFloat(parts[4])})
    },
    geocode(cluster) {
      if (cluster.geocodedStart === null) {
        geocodeOM(cluster.start).then((results) => {
          cluster.geocodedStart = results[0].formatted_address
        })
        geocodeOM(cluster.end).then((results) => {
          cluster.geocodedEnd = results[0].formatted_address
        })
      }
    },
    use(cluster) {
      this.setOrigin(cluster.start);
      this.setDestination(cluster.end);
      this.$router.push('search');
    }
  }
}
</script>
