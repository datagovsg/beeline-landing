<template>
  <div>
    <template v-if="crowdstartRoute">
      <h3>Timing not Suitable? Propose something else!</h3>
      <crowdstart-from-route :route="crowdstartRoute"
        ref="routeEditor" @proposed-route-changed="proposedRoute = $event">
      </crowdstart-from-route>

      <button class="btn btn-primary" @click="createRoute">Submit!</button>
    </template>
  </div>
</template>

<script>
import { mapGetters, mapState, mapActions, mapMutations } from 'vuex'
import CrowdstartFromRoute from '../components/crowdstart-from-route.vue';
import RouteViewer from '../components/route-viewer.vue';
import MapPreview from '../components/map-preview.vue';
import geocode from '../utils/geocoder';
import {latlngDistance} from '../utils/latlngDistance';
import _ from 'lodash';
import assert from 'assert';

export default {
  components: {
    CrowdstartFromRoute,
    MapPreview,
    RouteViewer,
    CrowdstartFromRoute,
  },
  data() {
    return {
      offset: 0,
      localSettings: _.cloneDeep(this.$store.state.autogenerateSettings),
      stops: null,
      proposedRoute: null,
    }
  },
  created() {
    this.$http.get('https://api.beeline.sg/stops')
    .then(r => r.json())
    .then(stops => this.stops = stops)
  },
  computed: {
    ...mapState(['crowdstartRoute', 'adminIdToken']),
    routes() {
      return this.autogeneratedRoutes.slice(this.offset, 5)
    }
  },
  methods: {
    updateSetting() {
      this.$store.commit('setAutogenerateSettings', this.localSettings)
    },

    async createRoute() {
      var routeLabel = prompt('What is the route label?')

      if (!routeLabel)
        return;

      var date = '2017-06-01';
      var dateDate = new Date(date);

      var defaultOptions = {
        headers: {
          authorization: `Bearer ${this.adminIdToken}`
        }
      }

      var tripStops = this.proposedRoute.trips[0].tripStops
      var postRouteResponse = await this.$http.post('https://api.beeline.sg/routes', {
        label: routeLabel,
        from: tripStops[0].stop.description,
        to: tripStops[tripStops.length - 1].stop.description,
        transportCompanyId: 2, // Hard coded ACME company
        tags: ['autogen'],
        notes: {
          tier: [{
            price: 5,
            pax: 15,
          }],
          lelongExpiry: date
        },
        features: '# Autogenerated from suggestions'
      }, defaultOptions)

      assert.strictEqual(postRouteResponse.status, 200)

      var postTripResponse = await this.$http.post('https://api.beeline.sg/trips', {
        routeId: postRouteResponse.data.id,
        date: date,
        capacity: 50,
        price: '5.00',
        transportCompanyId: 2, // Hard coded ACME company
        tripStops: tripStops.map(ts => {
          var nearestStop = this.stops.map(s =>
            [s, latlngDistance(
              [ts.stop.coordinates.coordinates[1], ts.stop.coordinates.coordinates[0]],
              [s.coordinates.coordinates[1], s.coordinates.coordinates[0]]
            )]
          )
            .filter(([stop, distance]) => distance < 20)
            .map(([stop, distance]) => stop)[0]

          var time = new Date(ts.time);
          var stopTime = new Date(
            dateDate.getUTCFullYear(),
            dateDate.getUTCMonth(),
            dateDate.getUTCDate(),
            time.getHours(),
            time.getMinutes(),
            time.getSeconds()
          ).toISOString()

          if (nearestStop) {
            return {
              stopId: nearestStop.id,
              time: stopTime,
              canBoard: true,
              canAlight: true
            }
          } else {
            return {
              stop: nearestStop,
              time: stopTime,
              canBoard: true,
              canAlight: true
            }
          }
        })
      }, defaultOptions)

      // add the trip and trip stops
    }
  }
}
</script>
