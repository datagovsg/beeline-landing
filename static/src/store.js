import Vuex from 'vuex';
import Vue from 'vue';
import querystring from 'querystring';
import {latlngDistance} from './utils/latlngDistance';
import _ from 'lodash';
import jwtDecode from 'jwt-decode';

export function createStore() {
  var allLelongRoutes = Vue.resource('https://api.beeline.sg/custom/lelong/status')
    .get()
    .then(r => r.json())
    .then(rs => {
      for (let route of rs) {
        for (let trip of route.trips) {
          trip.tripStops = _.sortBy(trip.tripStops, 'time')
        }
      }
      rs.trips = _.sortBy(rs.trips, 'date')
      return rs;
    });

  var store = new Vuex.Store({
    state: {
      origin: null,
      destination: null,
      selectedRoute: null,
      similarRequests: null,

      runningRoutes: null,
      crowdstartedRoutes: null,
      autogeneratedRoutes: null,
      loadingRequests: 0,

      maxDistance: 1000,
      autogenerateSettings: {
        maxDetourMinutes: 2,
        startClusterRadius: 3000,
        endClusterRadius: 3000,
        startWalkingDistance: 300,
        endWalkingDistance: 300,
        dataSource: 'suggestions'
      },

      crowdstartRoute: {},

      idToken: null,
      profile: null,

      suggestions: null,

      now: Date.now(),
    },
    mutations: {
      setOrigin(state, origin) {
        state.origin = origin;
      },
      setDestination(state, destination) {
        state.destination = destination;
      },
      setSelectedRoute(state, route) {
        state.selectedRoute = route;
      },
      setSimilarRequests(state, requests) {
        state.similarRequests = requests;
      },
      incrementLoading(state) {
        state.loadingRequests++;
      },
      decrementLoading(state) {
        state.loadingRequests--;
      },
      setRunningRoutes(state, routes) {
        state.runningRoutes = routes;
      },
      setAutogeneratedRoutes(state, routes) {
        state.autogeneratedRoutes = _.cloneDeep(routes);
      },
      setCrowdstartedRoutes(state, routes) {
        state.crowdstartedRoutes = routes;
      },
      setAutogenerateSettings(state, settings) {
        state.autogenerateSettings = settings;
      },
      crowdstartRoute(state, route) {
        state.crowdstartRoute = route;
      },

      setProfile(state, {profile, idToken}) {
        // Persist to local storage
        try {
          window.localStorage['profile'] = JSON.stringify(profile)
          window.localStorage['idToken'] = idToken;
        } catch (err) {}

        state.profile = profile;
        state.idToken = idToken;
      },
      updateTimestamp(state) {
        state.now = Date.now();
      },
      setSuggestions(state, suggestions) {
        state.suggestions = suggestions;
      }
    },
    getters: {
      decodedIdToken: state => {
        if (!state.idToken) {
          return null;
        } else {
          return jwtDecode(state.idToken);
        }
      },
      idTokenState: state => {
        if (!state.idToken) {
          return Promise.resolve(false);
        } else {
          var token;
          try {
            token = jwtDecode(state.idToken);
          } catch (err) {
            return Promise.resolve(false);
          }

          if (!token.exp || token.exp * 1000 > (state.now + 10 * 6000)) {
            return Promise.resolve(true);
          } else {
            return Promise.resolve(false);
          }

          // TODO: Handle refresh tokens
        }
      }
    },
    actions: {
      checkIdToken(context) {
        context.commit('updateTimestamp')

        context.getters.idTokenState
        .then((r) => {
          if (!r) {
            context.commit('setProfile', {profile: null, idToken: null})
          }
        })
      },
      fetchSimilarRequests(context) {
        if (context.state.origin && context.state.destination) {
          Vue.resource('https://api.beeline.sg/suggestions/web/similar?' + querystring.stringify({
            startLat: context.state.origin.lat,
            startLng: context.state.origin.lng,
            endLat: context.state.destination.lat,
            endLng: context.state.destination.lng,
            startDistance: context.state.maxDistance,
            endDistance: context.state.maxDistance,
          })).get()
          .then(r => r.json())
          .then(rs => {
            context.commit('setSimilarRequests', rs);
          });
        }
      },
      processRequest(context) {
        // Take the origin, destination, and start fetching
        context.dispatch('fetchRunningRoutes')
        context.dispatch('fetchCrowdstartedRoutes')
        context.dispatch('fetchAutogeneratedRoutes')
      },
      fetchRunningRoutes(context) {
        if (context.state.origin && context.state.destination) {
          context.commit('incrementLoading');

          Vue.resource('https://api.beeline.sg/routes/search_by_latlon?' + querystring.stringify({
            startLat: context.state.origin.lat,
            startLng: context.state.origin.lng,
            endLat: context.state.destination.lat,
            endLng: context.state.destination.lng,
            maxDistance: context.state.maxDistance,
            tags: JSON.stringify(['public']),
          })).get()
          .then(r => r.json())
          .then(rs => {
            for (let route of rs) {
              for (let trip of route.trips) {
                trip.tripStops = _.sortBy(trip.tripStops, 'time')
              }
            }
            rs.trips = _.sortBy(rs.trips, 'date')

            context.commit('setRunningRoutes', rs);
          })
          .catch(err => console.error(err))
          .finally(() => context.commit('decrementLoading'))
        }
      },
      fetchCrowdstartedRoutes(context) {
        if (context.state.origin && context.state.destination) {
          context.commit('incrementLoading');

          allLelongRoutes.then((routes) => routes.filter(route =>
            _.some(route.trips[0].tripStops, ts => ts.canBoard &&
                latlngDistance([ts.stop.coordinates.coordinates[1], ts.stop.coordinates.coordinates[0]],
                               [context.state.origin.lat, context.state.origin.lng]) < context.state.maxDistance) &&
                _.some(route.trips[0].tripStops, ts => ts.canAlight &&
                latlngDistance([ts.stop.coordinates.coordinates[1], ts.stop.coordinates.coordinates[0]],
                               [context.state.destination.lat, context.state.destination.lng]) < context.state.maxDistance)
          ))
          .then((filteredRoutes) => context.commit('setCrowdstartedRoutes', filteredRoutes))
          .catch(err => console.error(err))
          .finally(() => context.commit('decrementLoading'))
        }
      },
      fetchAutogeneratedRoutes(context) {
        if (context.state.origin && context.state.destination) {
          context.commit('incrementLoading');

          Vue.resource('/routes/propose?' + querystring.stringify({
            origin_lat: context.state.origin.lat,
            origin_lng: context.state.origin.lng,
            destination_lat: context.state.destination.lat,
            destination_lng: context.state.destination.lng,
            settings: JSON.stringify({})
          })).get()
          .then(r => r.json())
          .then(rs => {
            if (rs.status === 'success') {
              // Take only the ten routes with the most number of passengers
              const routesSortedByPax = _.sortBy(rs.payload, route => - _.sumBy(route.requests, r => r.weight));
              context.commit('setAutogeneratedRoutes', routesSortedByPax)
            } else {
              throw new Error(rs.payload);
            }
          })
          .catch(err => console.error(err))
          .finally(() => context.commit('decrementLoading'));
        }
      },
      fetchSuggestions(context) {
        if (context.state.idToken) {
          Vue.http.get('http://localhost:8989/suggestions/web',
          {
            headers: {
              authorization: `Bearer ${context.state.idToken}`
            }
          })
          .then(r => r.data)
          .then(results => {
            context.commit('setSuggestions', results);
          })
          .catch(() => {
            context.commit('setSuggestions', null);
          })
        } else {
          context.commit('setSuggestions', null);
        }
      }
    }
  })

  const throttledHandler = _.throttle(() => {
    store.dispatch('fetchSimilarRequests')
    store.dispatch('processRequest')
  }, 300, {leading: false, trailing: true})

  store.watch(state => state.origin, throttledHandler)
  store.watch(state => state.destination, throttledHandler)
  store.watch(state => state.autogenerateSettings, () => {
    store.dispatch('fetchAutogeneratedRoutes')
  })


  store.commit('setProfile',
    {
      profile: JSON.parse(window.localStorage['profile'] || 'null'),
      idToken: window.localStorage['idToken'] || null
    });

  return store;
}
