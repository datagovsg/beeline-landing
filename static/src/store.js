import Vuex from 'vuex';
import Vue from 'vue';
import querystring from 'querystring';
import {latlngDistance} from './utils/latlngDistance';
import _ from 'lodash';

export function createStore() {
  var allLelongRoutes = Vue.resource('https://api.beeline.sg/custom/lelong/status')
    .get()
    .then(r => r.json())
    .then(rs => {
      for (let route of rs) {
        for (let trip of route.trips) {
          trip.tripStops = _.sortBy(trip.tripStops, 'time')
        }
      }
      rs.trips = _.sortBy(rs.trips, 'date')
      return rs;
    });

  var store = new Vuex.Store({
    state: {
      origin: null,
      destination: null,
      selectedRoute: null,
      similarRequests: null,

      runningRoutes: null,
      crowdstartedRoutes: null,
      autogeneratedRoutes: null,
      loadingRequests: 0,

      maxDistance: 1000,
      autogenerateSettings: {
        maxDetourMinutes: 2,
        startClusterRadius: 4000,
        endClusterRadius: 4000,
        startWalkingDistance: 300,
        endWalkingDistance: 300,
        dataSource: 'suggestions'
      },

      crowdstartRoute: {}
    },
    mutations: {
      setOrigin(state, origin) {
        state.origin = origin;
      },
      setDestination(state, destination) {
        state.destination = destination;
      },
      setSelectedRoute(state, route) {
        state.selectedRoute = route;
      },
      setSimilarRequests(state, requests) {
        state.similarRequests = requests;
      },
      incrementLoading(state) {
        state.loadingRequests++;
      },
      decrementLoading(state) {
        state.loadingRequests--;
      },
      setRunningRoutes(state, routes) {
        state.runningRoutes = routes;
      },
      setAutogeneratedRoutes(state, routes) {
        state.autogeneratedRoutes = _.cloneDeep(routes);
      },
      setCrowdstartedRoutes(state, routes) {
        state.crowdstartedRoutes = routes;
      },
      setAutogenerateSettings(state, settings) {
        state.autogenerateSettings = settings;
      },
      crowdstartRoute(state, route) {
        state.crowdstartRoute = route;
      }
    },
    actions: {
      fetchSimilarRequests(context) {
        if (context.state.origin && context.state.destination) {
          Vue.resource('https://api.beeline.sg/suggestions/web/similar?' + querystring.stringify({
            startLat: context.state.origin.lat,
            startLng: context.state.origin.lng,
            endLat: context.state.destination.lat,
            endLng: context.state.destination.lng,
            startDistance: context.state.maxDistance,
            endDistance: context.state.maxDistance,
          })).get()
          .then(r => r.json())
          .then(rs => {
            context.commit('setSimilarRequests', rs);
          });
        }
      },
      processRequest(context) {
        // Take the origin, destination, and start fetching
        context.dispatch('fetchRunningRoutes')
        context.dispatch('fetchCrowdstartedRoutes')
        context.dispatch('fetchAutogeneratedRoutes')
      },
      fetchRunningRoutes(context) {
        if (context.state.origin && context.state.destination) {
          context.commit('incrementLoading');

          Vue.resource('https://api.beeline.sg/routes/search_by_latlon?' + querystring.stringify({
            startLat: context.state.origin.lat,
            startLng: context.state.origin.lng,
            endLat: context.state.destination.lat,
            endLng: context.state.destination.lng,
            maxDistance: context.state.maxDistance,
            tags: JSON.stringify(['public']),
          })).get()
          .then(r => r.json())
          .then(rs => {
            for (let route of rs) {
              for (let trip of route.trips) {
                trip.tripStops = _.sortBy(trip.tripStops, 'time')
              }
            }
            rs.trips = _.sortBy(rs.trips, 'date')

            context.commit('setRunningRoutes', rs);
          })
          .catch(err => console.error(err))
          .finally(() => context.commit('decrementLoading'))
        }
      },
      fetchCrowdstartedRoutes(context) {
        if (context.state.origin && context.state.destination) {
          context.commit('incrementLoading');

          allLelongRoutes.then((routes) => routes.filter(route =>
            _.some(route.trips[0].tripStops, ts => ts.canBoard &&
                latlngDistance([ts.stop.coordinates.coordinates[1], ts.stop.coordinates.coordinates[0]],
                               [context.state.origin.lat, context.state.origin.lng]) < context.state.maxDistance) &&
                _.some(route.trips[0].tripStops, ts => ts.canAlight &&
                latlngDistance([ts.stop.coordinates.coordinates[1], ts.stop.coordinates.coordinates[0]],
                               [context.state.destination.lat, context.state.destination.lng]) < context.state.maxDistance)
          ))
          .then((filteredRoutes) => context.commit('setCrowdstartedRoutes', filteredRoutes))
          .catch(err => console.error(err))
          .finally(() => context.commit('decrementLoading'))
        }
      },
      fetchAutogeneratedRoutes(context) {
        if (context.state.origin && context.state.destination) {
          context.commit('incrementLoading');

          Vue.resource('/routes/propose?' + querystring.stringify({
            origin_lat: context.state.origin.lat,
            origin_lng: context.state.origin.lng,
            destination_lat: context.state.destination.lat,
            destination_lng: context.state.destination.lng,
            settings: JSON.stringify({})
          })).get()
          .then(r => r.json())
          .then(rs => {
            if (rs.status === 'success') {
              // Take only the ten routes with the most number of passengers
              const routesSortedByPax = _.sortBy(rs.payload, route => - _.sumBy(route.requests, r => r.weight));
              context.commit('setAutogeneratedRoutes', routesSortedByPax)
            } else {
              throw new Error(rs.payload);
            }
          })
          .catch(err => console.error(err))
          .finally(() => context.commit('decrementLoading'));
        }
      }
    }
  })

  const throttledHandler = _.throttle(() => {
    store.dispatch('fetchSimilarRequests')
    store.dispatch('processRequest')
  }, 300, {leading: false, trailing: true})

  store.watch(state => state.origin, throttledHandler)
  store.watch(state => state.destination, throttledHandler)
  store.watch(state => state.autogenerateSettings, () => {
    store.dispatch('fetchAutogeneratedRoutes')
  })

  return store;
}
